# PingCode OpenAPI Golang SDK PRD

## 1. 产品背景与目标

### 1.1 背景

- PingCode 已提供较为完整的 OpenAPI 文档（参考 `docs/reference/openpingcode` 目录下的各模块：概览、认证、产品、项目、全局、测试、知识、DevOps 等）。
- 目前其他 Go 项目若要接入 PingCode：
  - 需要自行拼装 HTTP 请求、处理认证、错误码、重试等逻辑；
  - 容易出现重复实现、风格不统一、错误处理不规范等问题。
- 缺少一套**符合 Go 开发习惯、稳定、易用**的官方/准官方 SDK。

### 1.2 产品愿景

> 提供一套基于 PingCode OpenAPI 的 Golang SDK，屏蔽 HTTP 细节和认证流程，提供 type-safe、模块化的接口封装，让 Go 项目能像调用本地库一样使用 PingCode 能力。

### 1.3 目标

- 短期目标（V1）：
  - 支持核心模块的稳定访问：认证、项目、产品、测试、知识（最常用的几个）。
  - 提供统一的 Client 初始化方式、认证方式和错误处理规范。
  - 覆盖常见场景的示例代码，降低接入门槛。
- 中期目标（V2+）：
  - 覆盖 OpenAPI 文档中大部分/全部模块。
  - 增加自动生成部分代码的能力（基于 OpenAPI），减少维护成本。
  - 增强高阶能力：重试策略、限流、链路追踪（metrics/log/trace）等。

---

## 2. 使用人群与使用场景

### 2.1 目标用户

- 内部 Go 服务开发者：需要在微服务中访问 PingCode 数据或触发操作。
- 外部集成方：有较强 Go 能力，希望集成 PingCode 功能到自身产品中。
- 工具/脚本作者：通过 Go 编写 CLI、定时任务与 PingCode 交互。

### 2.2 典型使用场景

- 从项目管理系统中拉取项目信息、需求列表、测试结果等。
- 自动创建/更新任务、需求、测试用例，进行 CI/CD 集成。
- 将 PingCode 中的知识库内容与其他系统同步。
- 自定义报表/看板服务，从 PingCode 抽数做 BI 分析。

---

## 3. 产品范围（Scope）

### 3.1 范围内（Must Have）

- 基础能力：
  - Client 初始化与配置（BaseURL、自定义 HTTP Client、日志、超时等）。
  - 支持至少两种认证方式（具体以 OpenAPI 文档为准，例如：Token / OAuth2）。
  - 全局统一错误类型（比如 `type Error struct { Code, Message, Raw *http.Response }`）。
- 核心模块 SDK 封装（基于已有 OpenAPI 文档）：
  - 认证模块（auth）：认证相关接口（如获取 token / 刷新 token 等）。
  - 项目模块（project）：查询项目信息、列表、成员等。
  - 产品模块（ship）：需求、版本等操作。
  - 测试模块（testhub）：测试用例、测试计划、执行结果等。
  - 知识模块（wiki）：知识空间、文档获取等。
- 基础开发体验：
  - 统一的包结构和命名规范，符合 Go 通用习惯。
  - 清晰的错误处理模式，避免使用者再去解析原始 HTTP Response。
  - 样例代码：至少提供若干 end-to-end 示例（例如：创建项目、拉取测试结果等）。

### 3.2 可选范围（Nice to Have）

- 其它模块封装（global、devops 等）。
- 自动生成部分 Model 和 API Client 的工具（根据 OpenAPI）。
- 更高级别封装（例如：批量操作、分页迭代器、通用查询封装等）。

### 3.3 不在范围内（Out of Scope at V1）

- 多语言 SDK（本 PRD 仅面向 Golang）。
- 完整 GUI 配置工具（如图形化配置 Client 的桌面应用）。
- 跨进程分布式缓存/限流系统（只提供可扩展接口，具体实现由业务方负责）。

---

## 4. 功能设计

本章节从产品能力角度描述 SDK 应具备的功能与行为，不展开具体包结构、代码文件或内部实现细节。详细技术实现规范（包括包结构、数据结构划分等）见 `deployment.md`。

### 4.1 整体架构原则

- 模块化设计：SDK 按 PingCode 的业务领域（认证、项目、产品、测试、知识等）划分模块，保证每个模块专注于自身领域。
- 分层设计：对外暴露的 API 与底层 HTTP/序列化/重试等技术细节分层，调用方只看到稳定的 Go 接口。
- 显式行为：认证、错误处理、分页等行为在接口层面清晰可见，不依赖隐式魔法或复杂反射。

### 4.2 Client 与配置（产品视角）

- SDK 提供统一的 Client 初始化入口，调用方只需要提供必要的配置（如 BaseURL、认证信息、超时等），即可完成连接。
- 配置项必须有清晰的默认策略和文档说明，避免大量必须记忆的“隐性参数”。
- 认证方式、超时策略、重试策略等具体实现细节在技术规范中定义，本 PRD 只要求：
  - 用户易于理解和配置；
  - 默认配置对大多数场景“即插即用”；
  - 行为可预测、可观测。

### 4.3 模块能力（按领域）

- 每个领域模块（auth/project/ship/testhub/wiki 等）至少提供：
  - 常用查询能力（按 ID 查询、按条件列表查询等）。
  - 常见写操作（创建、更新、状态变更等），具体以 OpenAPI 字段为准。
  - 基础分页支持，能够在不关心底层实现细节的前提下遍历结果。
- 模块的对外接口样式应统一，便于使用者在不同模块之间迁移经验。

### 4.4 错误处理与用户体验

- SDK 必须提供统一的错误抽象，使调用方能区分：
  - 入参/调用错误；
  - 认证错误；
  - 服务器端错误；
  - 网络或解析错误。
- 具体错误类型结构与字段由技术规范（deployment.md）定义，本 PRD 只要求：
  - 错误信息足够说明问题，便于排查；
  - 不泄露敏感信息；
  - 行为在不同模块之间保持一致。

### 4.5 日志与调试体验

- SDK 应提供基础的调试支持（例如：可选启用请求/响应日志、错误日志等）。
- 默认配置下不应产生噪音日志，但需要在问题排查时可以方便地打开必要信息。
- 具体日志接口形式和注入方式由技术规范（deployment.md）约束，本 PRD 只强调：
  - 可观测；
  - 默认安静；
  - 易于集成到现有日志体系。

---

## 5. 非功能需求

### 5.1 性能

- 针对典型调用场景，SDK 本身不能成为明显瓶颈：
  - 使用高效 JSON 库（默认可使用标准库，若项目已有统一选择则遵从）。
  - 连接复用交由 `http.Client` 控制，避免每次创建新 Client。
- 避免过度分配和拷贝大对象。

### 5.2 稳定性与向后兼容（Never break userspace）

- SDK 版本需要与 OpenAPI 版本明确对应（例如语义化版本号）。
- 对外公开 API 一旦发布：
  - 禁止破坏性变更（签名变更、行为改变）；
  - 如必须变更，采用新增 API + 标记旧 API deprecated 的方式。
- 所有 breaking change 必须：
  - 明确在 release note 中说明；
  - 给出迁移路径。

### 5.3 安全性

- 不在日志中打印敏感信息（Token、密码、密钥等）。
- 合理设置默认超时，避免调用挂死。
- 提供 TLS/HTTPS 支持（默认必须是 HTTPS）。

---

## 6. 版本规划与里程碑

### 6.1 V0.1（PoC）

- 完成基础 Client 结构和 1~2 个模块的最小实现（例如：auth + project）。
- 能在内部 demo 服务中跑通真实调用流程。
- 提供基础示例代码和简单 README。

### 6.2 V1.0（可用于生产）

- 覆盖至少：auth、project、ship、testhub、wiki 核心接口。
- 对所有暴露 API 写单元测试 + 集成测试（在允许范围内）。
- 接入现有 CI（lint、test、build）并全部通过。
- 文档完善：
  - 使用说明；
  - 典型示例；
  - 版本兼容策略说明。

### 6.3 后续版本（V1.x+）

- 覆盖剩余模块（global、devops 等）。
- 引入生成工具，自动同步 OpenAPI 更新。
- 增强健壮性（重试策略、限流、metrics 等）。

---

## 7. 测试与验收标准

### 7.1 测试范围

- 单元测试：
  - Config、Client 初始化；
  - 各模块 Service 的输入校验、错误处理。
- 集成测试：
  - 在测试环境调用真实 PingCode OpenAPI（可通过配置开关控制）。
  - 验证主要 API 调用路径正确工作。

### 7.2 验收标准

- 所有单元测试、集成测试、lint、typecheck 全部通过。
- 使用 SDK 的示例应用可以稳定完成以下操作：
  - 使用配置初始化 Client；
  - 通过认证；
  - 拉取项目列表；
  - 对至少一个模块完成创建/查询/更新的闭环操作。
- 对外 API 接口 freeze，并在文档中记录。

---

## 8. 文档与示例

### 8.1 SDK 文档

- README：
  - SDK 简介；
  - 安装方式；
  - 快速开始示例。
- 参考文档：
  - 每个模块的 API 列表与调用示例；
  - 错误类型说明；
  - 配置项说明。

> 注意：修改或新增影响用户使用的行为时，必须同步更新相关文档，特别是初始化方式、认证方式、错误处理策略等。

### 8.2 示例代码

- `examples/basic_usage`：最小可运行例子：
  - 读取环境变量中的 Token；
  - 初始化 Client；
  - 拉取项目列表并打印。
- `examples/ci_integration`：展示如何在 CI 中使用 SDK 获取测试结果/构建状态等。

---

## 9. 风险与对策

### 9.1 OpenAPI 变更带来的破坏风险

- 对策：
  - 建立 OpenAPI 版本与 SDK 版本映射；
  - 增加简易的“变更检测”（例如在生成阶段检查 diff）。

### 9.2 过度封装导致的调试困难

- 对策：
  - 始终保留查看原始请求/响应信息的能力（受安全控制）；
  - 错误类型中包含必要的原始信息（状态码、部分 body）。
